#### 1.逃逸分析
根据虚拟机可以分析新创建对象的使用范围，决定是否在 Java 堆上分配内存的一项技术
#### 2.对象逃逸状
- 全局逃逸（GlobalEscape）
 - 对象是一个静态变量
 - 对象是一个已经发生逃逸的对象
 - 对象作为当前方法的返回值
- 参数逃逸
即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的
- 没有逃逸

#### 3.逃逸分析优化
- 锁消除
我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。  
例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。  
锁消除的 JVM 参数如下：
 - 开启锁消除：-XX:+EliminateLocks
 - 关闭锁消除：-XX:-EliminateLocks  
锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上
- 标量替换
 - 标量：基础类型和对象的引用，不能进一步分解
 - 聚合量：能被进一步分解的量就是聚合量，比如：对象
 对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

 如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能

 标量替换的 JVM 参数如下：

 - 开启标量替换：-XX:+EliminateAllocations
 - 关闭标量替换：-XX:-EliminateAllocations
 - 显示标量替换详情：-XX:+PrintEliminateAllocations

 标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

- 栈上分配  
当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。
